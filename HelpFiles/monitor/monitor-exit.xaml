<FlowDocument PagePadding="5,0,5,0" AllowDrop="True" NumberSubstitution.CultureSource="User" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"><Paragraph><Run FontFamily="Arial" FontWeight="Bold" FontSize="10.6666666666667" xml:space="preserve">monitor-exit </Run><Run FontFamily="Arial" FontWeight="Bold" FontSize="10.6666666666667" Foreground="#FFFF0000">vAA</Run></Paragraph><Paragraph><Run FontWeight="Bold" FontSize="10.6666666666667" Foreground="#FFFF0000">A:</Run><Run FontWeight="Bold" FontSize="10.6666666666667" xml:space="preserve"> </Run><Run FontSize="10.6666666666667">Reference-bearing register (8 bits)</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">Release the monitor for the indicated </Run><Run FontWeight="Bold" FontSize="10.6666666666667">object</Run><Run FontSize="10.6666666666667">.</Run></Paragraph><Paragraph><Run FontWeight="Bold" FontSize="10.6666666666667">Note</Run><Run FontSize="10.6666666666667">: If this instruction needs to throw an exception, it must do so as if the device has already advanced past the instruction. It maybe useful to think of this as the instruction successfully executing (in a sense), and the exception getting thrown after the instruction but before the next one gets a chance to run.This definition makes it possible for a method to use a monitor cleanup catch-all (e.g., finally) block as the monitor cleanup for that block itself, as a way to handle the arbitrary exceptions that might get thrown due to the historical implementation of Thread.stop(), while still managing to have proper monitor hygiene.</Run></Paragraph></FlowDocument>