<FlowDocument PagePadding="5,0,5,0" AllowDrop="True" NumberSubstitution.CultureSource="User" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"><Paragraph><Run FontWeight="Bold" FontSize="13.3333333333333"><Run.TextDecorations><TextDecoration Location="Underline" /></Run.TextDecorations>Introduction</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667">In dalvik's bytecode, registers are always 32 bits, and can hold any type of value. 2 registers are used to hold 64 bit types (Long and Double).</Run></Paragraph><Paragraph><Run FontWeight="Bold" FontSize="10.6666666666667">Specifying the number of registers in a method</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">There are two ways to specify how many registers are available in a method. the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">.registers</Run><Run FontSize="10.6666666666667" xml:space="preserve"> directive specifies the </Run><Run FontWeight="Bold" FontSize="10.6666666666667" xml:space="preserve">total </Run><Run FontSize="10.6666666666667" xml:space="preserve">number of registers in the method, while the alternate </Run><Run FontWeight="Bold" FontSize="10.6666666666667">.locals</Run><Run FontSize="10.6666666666667" xml:space="preserve"> directive specifies the number of non-parameter registers in the method. The total number of registers would also include however many registers are needed to hold the method parameters.</Run></Paragraph><Paragraph><Run FontWeight="Bold" FontSize="10.6666666666667">How method parameters are passed into a method</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667">When a method is invoked, the parameters to the method are placed into the last n registers. If a method has 2 arguments, and 5 registers (</Run><Run FontWeight="Bold" FontSize="10.6666666666667">v0-v4</Run><Run FontSize="10.6666666666667" xml:space="preserve">), the arguments would be placed into the last 2 registers - </Run><Run FontWeight="Bold" FontSize="10.6666666666667">v3</Run><Run FontSize="10.6666666666667" xml:space="preserve"> and </Run><Run FontWeight="Bold" FontSize="10.6666666666667">v4</Run><Run FontSize="10.6666666666667">.</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">The first parameter to a non-static methods is always the object that the method is being invoked on (the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">this</Run><Run FontSize="10.6666666666667" xml:space="preserve"> object)</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">For example, let's say you are writing a non-static method </Run><Run FontWeight="Bold" FontSize="10.6666666666667">LMyObject;-&gt;callMe(II)V</Run><Run FontSize="10.6666666666667" xml:space="preserve">. This method has 2 integer parameters, but it also has an implicit </Run><Run FontWeight="Bold" FontSize="10.6666666666667">LMyObject</Run><Run FontSize="10.6666666666667">; parameter before both integer parameters, so there are a total of 3 arguments to the method.</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667">Let's say you specify that there are 5 registers in the method (</Run><Run FontWeight="Bold" FontSize="10.6666666666667">v0-v4</Run><Run FontSize="10.6666666666667" xml:space="preserve">), with either the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">.registers 5</Run><Run FontSize="10.6666666666667" xml:space="preserve"> directive or the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">.locals 2</Run><Run FontSize="10.6666666666667" xml:space="preserve"> directive (i.e. 2 local registers + 3 parameter registers). When the method is invoked, the object that the method is being invoked on (i.e. the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">this</Run><Run FontSize="10.6666666666667" xml:space="preserve"> reference) will be in </Run><Run FontWeight="Bold" FontSize="10.6666666666667">v2</Run><Run FontSize="10.6666666666667" xml:space="preserve">, the first integer parameter will be in </Run><Run FontWeight="Bold" FontSize="10.6666666666667">v3</Run><Run FontSize="10.6666666666667" xml:space="preserve">, and the second integer parameter will be in </Run><Run FontWeight="Bold" FontSize="10.6666666666667">v4</Run><Run FontSize="10.6666666666667">.</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667">For static methods it's the same thing, except there isn't an implicit this argument.</Run></Paragraph><Paragraph><Run FontWeight="Bold" FontSize="13.3333333333333"><Run.TextDecorations><TextDecoration Location="Underline" /></Run.TextDecorations>Register names</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">There are two naming schemes for registers - the normal </Run><Run FontWeight="Bold" FontSize="10.6666666666667">v#</Run><Run FontSize="10.6666666666667" xml:space="preserve"> naming scheme and the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">p#</Run><Run FontSize="10.6666666666667" xml:space="preserve"> naming scheme for parameter registers. The first register in the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">p#</Run><Run FontSize="10.6666666666667" xml:space="preserve"> naming scheme is the first parameter register in the method. So let's go back to the previous example of a method with 3 arguments and 5 total registers. The following table shows the normal </Run><Run FontWeight="Bold" FontSize="10.6666666666667">v#</Run><Run FontSize="10.6666666666667" xml:space="preserve"> name for each register, followed by the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">p#</Run><Run FontSize="10.6666666666667" xml:space="preserve"> name for the parameter registers</Run></Paragraph><List MarkerStyle="Disc"><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">v0		</Run><Run FontSize="10.6666666666667">The first local register</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">v1		</Run><Run FontSize="10.6666666666667">The second local register</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">v2	 p0	</Run><Run FontSize="10.6666666666667">The first parameter register</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">v3	 p1	</Run><Run FontSize="10.6666666666667">The second parameter register</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">v4	 p2	</Run><Run FontSize="10.6666666666667">The third parameter register</Run></Paragraph></ListItem></List><Paragraph><Run FontSize="10.6666666666667">You can reference parameter registers by either name - it makes no difference.</Run></Paragraph><Paragraph><Run FontWeight="Bold" FontSize="10.6666666666667">Motivation for introducing parameter registers</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">The </Run><Run FontWeight="Bold" FontSize="10.6666666666667">p#</Run><Run FontSize="10.6666666666667" xml:space="preserve"> naming scheme was introduced as a practical matter, to solve a common annoyance when editing smali code.</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">Say you have an existing method with a number of parameters and you are adding some code to the method, and you discover that you need an extra register. You think "No big deal, I'll just increase the number of registers specified in the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">.registers</Run><Run FontSize="10.6666666666667" xml:space="preserve"> directive!".</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">Unfortunately, it isn't quite that easy. Keep in mind that the method parameters are stored in the last registers in the method. If you increase the number of registers - you change which registers the method arguments get put into. So you would have to change the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">.registers</Run><Run FontSize="10.6666666666667" xml:space="preserve"> directive and renumber every parameter register.</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">But if the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">p#</Run><Run FontSize="10.6666666666667" xml:space="preserve"> naming scheme was used to reference parameter registers throughout the method, you can easily change the number of registers in the method, without having to worry about renumbering any existing registers.</Run></Paragraph><Paragraph><Run FontWeight="Bold" FontSize="10.6666666666667">Long/Double values</Run></Paragraph><Paragraph><Run FontSize="10.6666666666667">As mentioned previously, long and double primitives (</Run><Run FontWeight="Bold" FontSize="10.6666666666667">J</Run><Run FontSize="10.6666666666667" xml:space="preserve"> and </Run><Run FontWeight="Bold" FontSize="10.6666666666667">D</Run><Run FontSize="10.6666666666667" xml:space="preserve"> respectively) are 64 bit values, and require 2 registers. This is important to keep in mind when you are referencing method arguments. For example, let's say you have a (non-static) method </Run><Run FontWeight="Bold" FontSize="10.6666666666667">LMyObject;-&gt;MyMethod(IJZ)V</Run><Run FontSize="10.6666666666667" xml:space="preserve">. The parameters to the method are </Run><Run FontWeight="Bold" FontSize="10.6666666666667">LMyObject</Run><Run FontSize="10.6666666666667" xml:space="preserve">;, </Run><Run FontWeight="Bold" FontSize="10.6666666666667">int</Run><Run FontSize="10.6666666666667" xml:space="preserve">, </Run><Run FontWeight="Bold" FontSize="10.6666666666667">long</Run><Run FontSize="10.6666666666667" xml:space="preserve">, </Run><Run FontWeight="Bold" FontSize="10.6666666666667">bool</Run><Run FontSize="10.6666666666667">. So this method would require 5 registers for all of its parameters.</Run></Paragraph><List MarkerStyle="Disc"><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">p0	 </Run><Run FontWeight="Bold" FontSize="10.6666666666667">this</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">p1	 </Run><Run FontWeight="Bold" FontSize="10.6666666666667">I</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">p2, p3	 </Run><Run FontWeight="Bold" FontSize="10.6666666666667">J</Run></Paragraph></ListItem><ListItem><Paragraph><Run FontFamily="Arial" FontSize="10.6666666666667" xml:space="preserve">p4	 </Run><Run FontWeight="Bold" FontSize="10.6666666666667">Z</Run></Paragraph></ListItem></List><Paragraph><Run FontSize="10.6666666666667" xml:space="preserve">Also, when you are invoking the method later on, you do have to specify both registers for any double-wide arguments in the register list for the </Run><Run FontWeight="Bold" FontSize="10.6666666666667">invoke-</Run><Run FontStyle="Italic" FontSize="10.6666666666667">kind</Run><Run FontSize="10.6666666666667" xml:space="preserve"> instruction.</Run></Paragraph></FlowDocument>